#!/bin/bash

# ===== Env =====

export PROJECT_HOME=~/Projects

if [[ "$PROJECT_HOME" == "" ]] then
    echo "Missing Environment Variable `PROJECT_HOME`"
fi

# Golang
export GOPATH="$HOME/go"
export PATH="$GOPATH/bin:$PATH"

# Istio
if [[ -d "$PROJECT_HOME/istio/istio-$ISTIO_VERSION/bin" ]] then
    export PATH=$PROJECT_HOME/istio/istio-$ISTIO_VERSION/bin:$PATH
    source $PROJECT_HOME/istio/istio-$ISTIO_VERSION/tools/_istioctl

    if [[ ! -f "/tmp/istio-$ISTIO_VERSION.json" ]] then
        istioctl profile dump demo -o json > /tmp/istio-$ISTIO_VERSION.json
    fi
fi

# Kubernetes

export PATH="$HOME/.krew/bin:$PATH"


# ===== Misc =====

alias tt="tmux -CC attach || tmux -CC"

alias mysql="mysql --default-character-set utf8"

alias dlv-attach="dlv --listen=:2345 --headless=true --api-version=2 attach"

alias kind="KUBECONFIG=$HOME/.kube/config kind"

alias minikube="KUBECONFIG=$HOME/.kube/config minikube"

# ===== Trip Laptop =====

proxy-trip-laptop(){
    LAN_IP=$(ip addr show $(ip -4 route ls | grep default | awk '{print $5}') | grep 'inet ' |  perl -pe 's/(.*inet )(\d+\.\d+\.\d+\.\d+)(\/\d+.*)/$2/g')
    ssh trip.dozer.cc -- "cat /etc/resolv.conf | perl -pe 's/^nameserver.*/nameserver 198.18.0.2/g' | sudo tee /etc/resolv.conf"
    ssh trip.dozer.cc -- "sudo ip route add default via $LAN_IP"
}

# Forward laptop minikube
forward-trip-laptop-minikube(){
    scp trip.dozer.cc:/home/dozer/.kube/config ~/.kube/clusters/trip-laptop
    mkdir -p ~/.kube/clusters/trip-laptop-cert
    scp trip.dozer.cc:/home/dozer/.minikube/ca.crt ~/.kube/clusters/trip-laptop-cert/ca.crt
    scp trip.dozer.cc:/home/dozer/.minikube/profiles/minikube/client.crt ~/.kube/clusters/trip-laptop-cert/client.crt
    scp trip.dozer.cc:/home/dozer/.minikube/profiles/minikube/client.key ~/.kube/clusters/trip-laptop-cert/client.key
    yq w -i ~/.kube/clusters/trip-laptop 'clusters[0].cluster.server' https://localhost:8443
    yq w -i ~/.kube/clusters/trip-laptop 'clusters[0].cluster.certificate-authority' $HOME/.kube/clusters/trip-laptop-cert/ca.crt
    yq w -i ~/.kube/clusters/trip-laptop 'users[0].user.client-certificate' $HOME/.kube/clusters/trip-laptop-cert/client.crt
    yq w -i ~/.kube/clusters/trip-laptop 'users[0].user.client-key' $HOME/.kube/clusters/trip-laptop-cert/client.key
    echo "kubeconfig: $HOME/.kube/clusters/trip-laptop"
    ssh -NT -L localhost:8443:$(ssh trip.dozer.cc -- minikube ip):8443 trip.dozer.cc
}

# ===== Kubernetes =====

# Format: image-name[,group-name]
KUBE_CACHED_IMAGES=(
    aylei/debug-agent:latest,debug
    dozer47528/devops-toolkits-docker:latest,debug
    dozer47528/devops-toolkits-docker:benchmark,debug
    nginx:stable,debug
    golang:1.15,debug
)

if [[ -d "$PROJECT_HOME/istio/istio-$ISTIO_VERSION/bin" ]] && [[ -x "$(command -v jq)" ]] then
    KUBE_CACHED_IMAGES+=(
        docker.io/istio/proxyv2:${ISTIO_VERSION},istio
        istio/proxyv2:${ISTIO_VERSION},istio
        istio/pilot:${ISTIO_VERSION},istio
        quay.io/kiali/kiali:$(cat /tmp/istio-$ISTIO_VERSION.json | jq '..|.kiali?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
        grafana/grafana:$(cat /tmp/istio-$ISTIO_VERSION.json | jq '..|.grafana?.image?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
        prom/prometheus:$(cat /tmp/istio-$ISTIO_VERSION.json | jq '..|.prometheus?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
        jaegertracing/all-in-one:$(cat /tmp/istio-$ISTIO_VERSION.json | jq '..|.jaeger?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
    )
fi

# Load images to minikube, do not need to run it after create Minikube cluster everytime.
minikube-cache-image(){
    minikube cache list | xargs minikube cache delete
    rm -rf ~/.minikube/cache/images/*
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        i=$(echo $i | awk -F ',' '{print $1}')
        docker pull $i
        if [[ $i =~ "/" ]] && ! test -f ~/.minikube/cache/images/${i/:/_}; then
            mkdir -p ~/.minikube/cache/images/${i/:/_}
            rm -r ~/.minikube/cache/images/${i/:/_}
        fi
        docker save $i -o ~/.minikube/cache/images/${i/:/_}
        minikube cache add $i
    done
}

# Load host docker images to Kind on-demand, need to run it after create Kind cluster everytime.
# You pass the group name to this command like: `kind-load-images nginx`
kind-load-images(){
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        image=$(echo $i | awk -F ',' '{print $1}')
        group=$(echo $i | awk -F ',' '{print $2}')
        if [[ $1 == $group ]] || [[ $1 == "all" ]]; then
            docker pull $image
            kind load docker-image $image
        fi
    done
}

# Completions for `kind-load-images` command

_kind-load-images_completions(){
    COMPREPLY+=("all")
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        image=$(echo $i | awk -F ',' '{print $1}')
        group=$(echo $i | awk -F ',' '{print $2}')
        if [[ $image != "" ]] && (! [[ " ${COMPREPLY[@]} " =~ " ${group} " ]]); then
            COMPREPLY+=("$group")
        fi
    done
}
complete -F _kind-load-images_completions kind-load-images


pod-name(){
    kubectl get pod -l app=$1 -o jsonpath="{.items[0].metadata.name}"
}

kk() {
    uuid=$(uuidgen)
    if [[ $1 == "default" ]]; then
        cp ${HOME}/.kube/config ~/.tmp/${uuid}
    else
        cp ${HOME}/.kube/clusters/$1 ~/.tmp/${uuid}
    fi
    export KUBECONFIG=${HOME}/.tmp/${uuid}
}

_kk_completions(){
   COMPREPLY+=("default")
   COMPREPLY+=(`ls ~/.kube/clusters`)
}

complete -F _kk_completions kk


# External Disk

external-mount(){

MOUNT_SOURCE_HOME=/Volumes/External

MOUNT_TARGECTS=(
    "/Users/zhongyuan/.minikube"
    "/Users/zhongyuan/Library/Containers/com.docker.docker"
    "/Users/zhongyuan/Projects"
)

for t in ${MOUNT_TARGECTS[@]}; do
    mkdir -p "${MOUNT_SOURCE_HOME}${t}"
    rm -r "${t}"
    ln -s "${MOUNT_SOURCE_HOME}${t}" "${t}"
done

}

alias minikube-docker="eval $(minikube -p minikube docker-env | head -n 4 | sed 's/export//g' | tr '\n' ' ') docker"
